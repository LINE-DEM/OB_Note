## 核心摘要

前向声明的本质是**只告诉编译器"这个类型名存在"，不给内部细节**。它把类型分成"知道存在"和"知道细节"两个阶段，凡是不需要细节的场景（指针、引用）就能先用，需要细节的场景推迟到 `#include` 完整定义时再处理。

---

## 详细分析

### 底层原理 / 核心规律

编译器处理一个类型时需要两层信息：

```
第一层：符号存在性     → "Foo 是不是一个合法的类型名？"
第二层：内存布局/大小   → "Foo 占多少字节？内部有哪些字段？"
```

前向声明只提供第一层，第二层留到后续 `#include` 完整定义。

判断公式（核心）：

```
需要知道大小/成员？
  → 否 → 前向声明就够   （指针、引用、函数参数为指针）
  → 是 → 必须 include 完整定义  （值变量、sizeof、成员访问、继承）
```

> 根本原因：**指针/引用的大小是固定的**（32位 = 4字节，64位 = 8字节），不依赖于指向的类型细节。

---

### 具体用法（按难度从低到高排列）

---

#### 1. struct 的前向声明（C / C++）

**看代码**

```c
struct lex_process;              // 前向声明：只声明类型名

struct lex_process *p;           // ✅ 可以声明指针
void init(struct lex_process *proc);  // ✅ 可以作为指针参数
```

**拆解**

```c
struct lex_process;
↑↑↑↑↑↑ ↑↑↑↑↑↑↑↑↑↑↑
关键字   类型名          ← 无大括号、无成员、只有分号
                         // 编译器知道：lex_process 存在
                         // 编译器不知道：它里面有什么
```

**对比（区分前向声明 vs 完整定义）**

```c
struct Foo;              // 前向声明 → 无 {}，只有类型名 + ;
struct Foo {};           // 完整定义 → 有 {}（即使是空的）
struct Foo { int x; };   // 完整定义 → 有成员
```

---

#### 2. class 的前向声明（C++ 特有）

**看代码**

```cpp
class AWeapon;                   // C++ class 前向声明

class APlayer {
    AWeapon *weapon;             // ✅ 指针 → 不需要知道 AWeapon 细节
};
```

**拆解**

```cpp
class AWeapon;
↑↑↑↑↑ ↑↑↑↑↑↑↑
关键字  类型名   ← 和 struct 前向声明语法完全一样，只是关键字不同
```

**C++ 的特殊点：struct 和 class 可以互相前向声明**

```cpp
// 定义时用 struct，前向声明时用 class → 合法！
class Foo;                // 前向声明（用了 class）
struct Foo { int x; };    // 定义（用了 struct）← 不矛盾

// 反过来也行：
struct Bar;               // 前向声明（用了 struct）
class Bar { public: int x; };  // 定义（用了 class）← 同样合法
```

> **注意**：这个特性是 C++ 独有的。C 中 struct 就是 struct，没有 class 概念。

---

#### 3. 不完全类型的边界规则

这是前向声明最容易踩雷的地方。前向声明后的类型学术上叫**不完全类型（incomplete type）**。

**看代码（✅ 能做的）**

```c
struct Foo;                          // 前向声明

struct Foo *p;                       // ✅ 指针声明
struct Foo *create(void);            // ✅ 返回指针
void destroy(struct Foo *p);         // ✅ 指针参数
struct Bar { struct Foo *ref; };     // ✅ 嵌套指针成员
```

**看代码（❌ 不能做的）**

```c
struct Foo;                          // 前向声明

struct Foo obj;                      // ❌ 值变量 → 不知道大小
sizeof(struct Foo);                  // ❌ 不知道大小
obj.field;                           // ❌ 不知道有哪些成员
void fn(struct Foo obj);             // ❌ 值参数 → 不知道大小
struct Bar { struct Foo val; };      // ❌ 嵌套值成员 → 不知道大小
```

**拆解（判断核心）**

```
操作涉及类型本身的大小或内部？
   ↓ 否                    ↓ 是
   ✅ 前向声明够用            ❌ 必须 include 完整定义
   （指针/引用/函数签名）      （值变量/sizeof/成员访问/继承）
```

---

#### 4. 循环依赖：.h 与 .cpp 的配合模式

前向声明最经典的用场：两个类型互相引用。

**看代码**

```c
// === Egg.h ===
struct Chicken;                      // ← 前向声明 Chicken（不 include Chicken.h）
struct Egg {
    struct Chicken *hatcher;         // 只用指针 → 前向声明就够
};

// === Chicken.h ===
struct Egg;                          // ← 前向声明 Egg（不 include Egg.h）
struct Chicken {
    struct Egg *laid_egg;            // 只用指针 → 前向声明就够
};

// === Egg.c ===
#include "Egg.h"
#include "Chicken.h"                 // ← .cpp 里才 include 完整定义

void egg_set_hatcher(struct Egg *e, struct Chicken *c) {
    e->hatcher = c;                  // 这里访问成员 → 需要完整定义
}
```

**拆解（模式总结）**

```
.h 文件（对外接口）          .cpp 文件（实现细节）
━━━━━━━━━━━━━━━━            ━━━━━━━━━━━━━━━━━━━
前向声明 → 用指针             #include 完整头文件
↑ 不知道细节，但够用           ↑ 现在知道细节，可以访问成员
```

**不用前向声明的话会怎样？**

```
Egg.h  →  #include "Chicken.h"
Chicken.h →  #include "Egg.h"
              ↑ 循环 include！编译器报错（或被 #pragma once 截断导致
                其中一个类型未定义）
```

---

#### 5. 函数原型（函数的"前向声明"）

函数也有前向声明的概念，叫**函数原型（prototype）**。和 struct/class 前向声明对比看更清楚。

**看代码**

```c
// 函数原型（前向声明）：只声明签名，无函数体
int add(int a, int b);

// 先用
int result = add(3, 2);            // ✅ 编译器已经知道签名

// 函数定义放在后面（或者在另一个 .c 文件里）
int add(int a, int b) {
    return a + b;
}
```

**拆解**

```c
int add(int a, int b);
↑↑↑ ↑↑↑  ↑↑↑↑↑↑↑↑↑↑↑
返回值 函数名  参数签名   ← 必须写完整签名（和 struct 不同！）
```

**和 struct 前向声明对比**

```
struct 前向声明：struct Foo;         → 只有类型名，无细节
函数原型：       int add(int, int);  → 必须写完整签名（返回值 + 参数类型）
                                       ↑ 因为调用时编译器需要知道参数怎么传、返回值怎么接
```

---

### 快速读法

遇到前向声明时，三步判断：

```
第一步：确认是不是前向声明
   → 看有没有 {}（大括号）
   → 无 {} + 只有类型名 + ; → 前向声明
   → 有 {} → 完整定义

第二步：后续代码怎么用这个类型？
   → 只做指针/引用 → 前向声明够用，不需要 include
   → 要访问成员/声明值变量 → 必须找到并 include 完整定义

第三步：找完整定义在哪？
   → 通常在对应的 .h 头文件里
   → 前向声明的文件不 include 它，实现的 .cpp 才 include
```

---

## 关联知识

- `[[指针]]` — 指针大小固定是前向声明能工作的根本原因；不完全类型只能配指针使用
- `[[Struct]]` — struct 的完整声明语法，和前向声明做对比（有 `{}` vs 无 `{}`）
- `[[函数指针]]` — 函数指针参数配合前向声明使用，如 `void foo(struct Bar *p, int (*cb)(struct Bar*))`
- `[[c和c++]]` — C++ 中 class/struct 可以互相前向声明，C 中无此特性
- 深度分析：`[[前向声明]]`（架构视角）— 编译依赖管理、UE 头文件优化策略
