---
creation_date: 2026-02-04 15:10
type: #Type/Concept
status: #Status/Refactoring
tags: [指针, pointer, 解引用, 取地址, 指针运算, 内存地址]
aliases: [pointer, 解引用, 取地址, 指针运算, 二级指针]
tech_stack: #Tech/CPP
complexity: ⭐⭐⭐
related_modules: []
---

## 核心摘要

`*` 在 C/C++ 中有**两种身份**，全靠上下文判断：声明时是"声明这个变量是指针"，表达式中是"访问指针指向的值（解引用）"。掌握这个切换规则，所有指针写法都能从中推出来。

---

## 详细分析

### 底层原理 / 核心规律

指针本质是**存储内存地址的变量**。围绕它有三个核心运算符：

```
&  取地址：  变量 → 地址        p = &x;     // 把 x 的地址存到 p
*  解引用：  地址 → 值           *p = 20;    // 通过地址访问/修改值
-> 成员访问：指针 → 成员          p->field;   // 等价于 (*p).field
```

`*` 的两种身份（最容易混的点）：

```
声明中：   int *p;     → * 是声明语法，表示 p 是一个指针变量
表达式中：  *p = 10;   → * 是解引用运算符，表示"访问 p 指向的那个值"
```

> **判断依据**：看 `*` 出现在等号左边还是声明语句里 → 声明；出现在赋值/表达式里 → 解引用。

---

### 具体用法（按难度从低到高排列）

---

#### 1. 基础声明、赋值与解引用

**看代码**

```c
int  x  = 10;
int *p  = &x;   // 声明指针，赋值 x 的地址
*p      = 20;   // 解引用：通过 p 修改 x
// 此时 x == 20
```

**拆解**

```c
int *p = &x;
↑↑↑ ↑↑   ↑↑
类型 指针名  取地址（& = 获取变量的内存地址）

*p = 20;
↑↑
解引用（* = 通过地址访问指向的值）
```

**核心对齐关系**：`&` 和 `*` 互为逆操作。

```
&x   →   拿到地址
*p   →   用地址拿回值
// &(*p) == p，*(&x) == x
```

---

#### 2. 声明易错点：`*` 只修饰紧邻的变量名

**看代码**

```c
int *a, b;     // a 是 int*，b 是 int ← 易错！
int *a, *b;    // a 和 b 都是指针 ← 正确写法
```

**拆解**

```c
int *a, b;
    ↑↑  ↑
    指针  普通 int（* 只管 a，不管 b）
```

**对比（风格易陷阱）**

```c
int* a, b;   // 看起来像 "int* 是类型，a b 都是这个类型"
             // 实际：b 仍然是 int ← 视觉误导
int *a, *b;  // 每个变量自带 * ← 明确，推荐
```

> **规律**：`*` 在声明中属于**变量名**一侧，不属于类型一侧。要让哪个变量是指针，就在哪个变量前面加 `*`。

---

#### 3. 指针运算（pointer arithmetic）

**看代码**

```c
int arr[] = {10, 20, 30, 40};
int *p = arr;          // p 指向 arr[0]

int *next = p + 1;     // 不是 +1 字节！是向后移动一个 int
int val   = *(p + 2);  // 访问 arr[2] = 30
```

**拆解**

```c
*(p + 2)
↑  ↑   ↑
解引用 基地址 偏移量（单位 = sizeof(int)，不是字节）
```

**核心公式**：

```
p + n   →   实际地址 = (char*)p + n * sizeof(*p)
// 加 n，实际移动 n * 元素大小 的字节数
```

**为什么用**：遍历数组、访问连续内存区域（显存、网络缓冲区、文件映射）时的基础操作。

---

#### 4. 数组与指针的衰变关系

**看代码**

```c
int arr[] = {1, 2, 3, 4};
int *p = arr;           // 数组名自动"衰变"为指向首元素的指针

// 以下三种写法完全等价：
arr[2];                 // 数组语法
p[2];                   // 指针 + 下标
*(p + 2);               // 指针运算 + 解引用
// 结果都是 3
```

**拆解（编译器实际执行的）**

```
arr[2]  →  *(arr + 2)
↑↑↑↑↑↑    ↑  ↑↑↑   ↑
人类写法   解引用 基地址 偏移  ← 底层都转成这个
```

**对比**

```c
// 数组语糖 vs 指针本质：
arr[i];       // 写起来方便
*(arr + i);   // 编译器看到的实际操作

// 甚至可以反写（合法但诡异，别写）：
2[arr];       // 等价于 *(2 + arr) = *(arr + 2) = arr[2]
```

> **衰变例外**：数组名在 `sizeof` 和 `&` 面前不衰变。`sizeof(arr)` 返回整个数组的字节数，`&arr` 返回整个数组的地址（类型是 `int(*)[4]`，和 `arr` 衰变后的 `int*` 不同）。

---

#### 5. 多级指针（指针的指针）

**看代码**

```c
int    x  = 42;
int   *p  = &x;      // p  存 x 的地址
int  **pp = &p;      // pp 存 p 的地址

// 逐层解引用：
*pp;                 // → p 的值（x 的地址）
**pp;                // → x 的值 = 42
```

**拆解**

```c
int **pp = &p;
↑↑↑ ↑↑↑↑
类型 二级指针名（两个 * = 指向指针的指针）
```

**实际场景：`main` 的 `argv`**

```c
int main(int argc, char **argv);
//                      ↑↑↑↑↑↑↑↑
//                      指向 char* 的指针 = 字符串数组

// argv[0] = 程序名
// argv[1] = 第一个命令行参数
// argv[argc] = NULL（哨兵）
```

> **快速理解多级指针**：看有几个 `*`，就是几层间接寻址。每写一个 `*` 解引用就剥掉一层。

---

### 快速读法

遇到复杂的指针声明，按步骤拆解：

```
1. 找变量名 → 通常是最右边那个标识符
2. 看变量名左边有几个 * → 几级指针
3. 看最左边的类型 → 最终指向什么类型
4. 看右边有没有 [] → 涉及数组指针（见[[函数指针]]笔记的读法）
```

示例：`char **argv`
- 变量名：argv
- 两个 `*` → 二级指针
- 基础类型：char
- 含义：指向 `char*` 的指针 → 即字符串数组

---

## 关联知识

- `[[函数指针]]` — `*` 在函数指针声明中位置特殊（需要括号`(*fp)`），和本篇 `*` 的声明规则做对比
- `[[Struct]]` — struct 配合指针时的 `->` 运算符，以及嵌套自引用（`struct Node *next`）必须用指针
- `[[前向声明]]` — 前向声明时类型大小未知，只能用指针声明变量
- `[[c和c++]]` — C++ 引入了引用（`&`）作为指针的安全替代，但指针在低层操作中依然不可避免
- `c++汇编/指针` — 汇编层面的视角：指针本质就是地址值放进寄存器或栈中
