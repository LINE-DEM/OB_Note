## 核心摘要

函数指针的本质：**声明语法和普通函数完全一样，唯一区别是把"函数名"换成"(*指针名)"** —— 记住这一个公式，所有写法都能推出来。

---

## 详细分析

### 底层原理 / 核心规律

函数在编译后就是一段内存中的代码，函数名本身就是该段代码的**起始地址**。函数指针就是存储这个地址的指针变量。

声明公式（核心规律）：

```
普通函数：  返回值  函数名   (参数列表)
函数指针：  返回值 (*指针名) (参数列表)
                  ↑
            唯一的区别：外加一层括号 + *
```

> **括号必须加**：如果不加括号，`*` 会和返回值结合，变成"返回指针的函数"，语义完全不同。

---

### 具体用法（按难度从低到高排列）

---

#### 1. 基础声明与调用

**看代码**

```c
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int (*fp)(int, int);   // 声明函数指针
fp = &add;             // 赋值（&可省略）
int result = fp(3, 2); // 调用 → result = 5
fp = sub;              // 换指向的函数
result = fp(3, 2);     // 调用 → result = 1
```

**拆解**

```c
int (*fp)(int, int);
↑↑↑  ↑↑↑↑  ↑↑↑↑↑↑↑↑↑
返回值  指针名   参数列表
```

**对比**

```c
// 不加括号 → 变成"返回 int* 的函数声明"，完全不同！
int *fp(int, int);    // ❌ 这是函数声明，不是指针
int (*fp)(int, int);  // ✅ 这才是函数指针
```

---

#### 2. typedef 简化声明

**看代码**

```c
typedef int (*MathOp)(int, int);   // 定义函数指针类型

MathOp fp1 = add;
MathOp fp2 = sub;
```

**拆解**

```c
typedef int (*MathOp)(int, int);
↑↑↑↑↑↑↑ ↑↑↑  ↑↑↑↑↑↑↑  ↑↑↑↑↑↑↑↑↑
typedef  返回值  新类型名   参数列表
```

**核心规律回归**：typedef 的通用公式是"把变量名的位置换成新类型名"。函数指针里变量名就是 `(*fp)`，所以新类型名放在同一位置 `(*MathOp)`。

---

#### 3. 函数指针作为参数（回调）

**看代码**

```c
typedef int (*MathOp)(int, int);

void calculate(int a, int b, MathOp op) {
    printf("result = %d\n", op(a, b));
}

// 调用时传入不同函数
calculate(5, 3, add);  // result = 8
calculate(5, 3, sub);  // result = 2
```

**拆解**

```c
void calculate(int a, int b, MathOp op);
                              ↑↑↑↑↑↑  ↑↑
                              类型名   参数名
// op 就是普通参数，类型恰好是函数指针
```

**为什么用**：回调模式的核心场景。调用者决定"要做什么"，但具体逻辑由传入的函数决定。

---

#### 4. 函数指针数组（跳表）

**看代码**

```c
typedef int (*MathOp)(int, int);

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }

MathOp ops[] = { add, sub, mul };  // 函数指针数组

ops[0](4, 2);  // → 6  (add)
ops[1](4, 2);  // → 2  (sub)
ops[2](4, 2);  // → 8  (mul)
```

**拆解**

```c
MathOp ops[] = { add, sub, mul };
↑↑↑↑↑↑ ↑↑↑↑↑↑  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
类型名  数组名    初始化列表（函数名即地址）
```

**不用 typedef 的写法（对比）**：

```c
int (*ops[])(int, int) = { add, sub, mul };
//  ↑↑↑↑↑↑
//  数组名放在 * 后面，再加 []
```

**为什么用**：通过下标直接跳转到对应函数，省掉 if/switch，本质就是一个**跳表**。

---

#### 5. C++ 成员函数指针

**看代码**

```cpp
struct Dog {
    void bark() { printf("Woof!\n"); }
    void sit()  { printf("Sit!\n"); }
};

// 成员函数指针声明：类名::* 放在中间
void (Dog::*action)();

action = &Dog::bark;

Dog d;
(d.*action)();       // 调用 → "Woof!"
action = &Dog::sit;
(d.*action)();       // 调用 → "Sit!"
```

**拆解**

```cpp
void (Dog::*action)();
↑↑↑↑  ↑↑↑↑↑↑↑↑↑↑↑↑  ↑↑
返回值  类名::*指针名   参数列表
```

**对比普通函数指针**：

```cpp
void (*fp)();          // 普通函数指针：    (*名)
void (Dog::*action)(); // 成员函数指针：(类名::*名)  ← 多了 类名::
```

**为什么用**：需要动态选择"调用哪个成员函数"时使用，比如状态机中每个状态对应不同的成员方法。

---

### 快速读法

遇到一个陌生的函数指针声明时，按以下步骤拆解：

```
1. 找括号内的 * → 那就是指针变量名（或新类型名）
2. 括号左边    → 返回值类型
3. 括号右边    → 参数列表
4. 如果有 类名:: → 这是成员函数指针
```

示例：`int (*(*fp)(int))(double)` 拆解：
- 最里面的 `*fp` → fp 是指针
- `(*fp)(int)` → fp 接受 int 参数，返回...
- `int (*...)(double)` → 返回一个"接受 double、返回 int 的函数指针"
- **结论**：fp 是一个接受 int、返回函数指针的函数指针

---

## 关联知识

- `[[虚函数]]` — C++ 的虚函数表（vtable）本质就是一个函数指针数组，每个表项存储一个成员函数指针
- `[[c和c++]]` — C 中用函数指针模拟多态，C++ 用虚函数替代了大部分场景
- `[[C++模板使用与实现细节]]` — 模板结合函数指针时的实例化机制
