# 为什么 VS2022 编译的 DLL 需要安装 VC++ 运行时？

  

> 一份深入浅出的技术解析，带你理解 C/C++ 程序的运行时依赖机制

  

## 引言：一个常见的困惑

  

你可能遇到过这样的场景：

  

- 在自己电脑上开发的程序运行得好好的

- 发给别人却报错："找不到 VCRUNTIME140.dll"

- 或者更隐蔽的："DLL 初始化例程失败"

  

为什么会这样？要理解这个问题，我们需要从 C/C++ 程序的本质说起。

  

---

  

## 第一章：C/C++ 程序不是"独立"的

  

### 1.1 你写的代码只是冰山一角

  

当你写下这样一行简单的 C++ 代码：

  

```cpp

#include <iostream>

  

int main() {

    std::cout << "Hello World" << std::endl;

    return 0;

}

```

  

你可能以为这就是程序的全部。但实际上，**你写的代码只占最终程序的很小一部分**。

  

`std::cout` 是怎么把文字显示到屏幕上的？它需要：

- 调用操作系统的 API

- 处理字符编码转换

- 管理输出缓冲区

- 处理多线程同步

- ……

  

这些复杂的实现代码，你没写，但程序运行时必须有。**它们就藏在"运行时库"里**。

  

### 1.2 一个类比：餐厅与厨房

  

把你的程序想象成一家餐厅：

  

```

┌─────────────────────────────────────────────────────────┐

│                      你的程序                            │

│  ┌─────────────────────────────────────────────────┐   │

│  │              你写的代码（菜单）                    │   │

│  │                                                  │   │

│  │   "我要一份 Hello World"                         │   │

│  │   "我要读取一个文件"                              │   │

│  │   "我要分配一块内存"                              │   │

│  └─────────────────────────────────────────────────┘   │

│                         ↓ 调用                          │

│  ┌─────────────────────────────────────────────────┐   │

│  │           运行时库（厨房 + 厨师）                  │   │

│  │                                                  │   │

│  │   printf 的实现、malloc 的实现、                  │

│  │   文件操作的实现、异常处理的实现……                 │   │

│  └─────────────────────────────────────────────────┘   │

│                         ↓ 调用                          │

│  ┌─────────────────────────────────────────────────┐   │

│  │              操作系统（食材供应商）                │   │

│  └─────────────────────────────────────────────────┘   │

└─────────────────────────────────────────────────────────┘

```

  

你写的代码就像菜单上的菜名，运行时库才是真正做菜的厨房和厨师。

  

**没有厨房，餐厅开不了。没有运行时库，程序跑不起来。**

  

---

  

## 第二章：什么是 VC++ 运行时库？

  

### 2.1 运行时库的组成

  

VC++ 运行时库（Visual C++ Runtime）包含以下核心组件：

  

```

VC++ 运行时库

├── C 运行时库 (CRT - C Runtime Library)

│   ├── 标准 C 函数：printf, scanf, malloc, free, fopen...

│   ├── 数学函数：sin, cos, sqrt, pow...

│   ├── 字符串函数：strcpy, strlen, strcmp...

│   └── 内存管理：堆分配、堆释放

│

├── C++ 标准库

│   ├── iostream：cout, cin, cerr

│   ├── string：std::string

│   ├── 容器：vector, map, list...

│   ├── 算法：sort, find, transform...

│   └── 智能指针：shared_ptr, unique_ptr

│

└── 编译器支持库

    ├── 异常处理机制

    ├── RTTI（运行时类型识别）

    ├── 64位整数运算支持

    └── 安全检查函数（_s 后缀函数）

```

  

### 2.2 那些你见过的 DLL 文件

  

当你安装 VC++ Redistributable 时，实际上安装了这些文件：

  

```

C:\Windows\System32\

├── vcruntime140.dll      ← 核心运行时（140 = VS2015+）

├── vcruntime140_1.dll    ← 扩展运行时

├── msvcp140.dll          ← C++ 标准库

├── msvcp140_1.dll        ← C++ 标准库扩展

├── msvcp140_2.dll        ← C++ 标准库扩展

├── concrt140.dll         ← 并发运行时

├── vccorlib140.dll       ← Windows Runtime 支持

└── ucrtbase.dll          ← 通用 C 运行时（Windows 10 自带）

```

  

**文件名中的数字含义**：

- `140` = Visual Studio 2015/2017/2019/2022（它们共享同一套运行时）

- `120` = Visual Studio 2013

- `110` = Visual Studio 2012

- `100` = Visual Studio 2010

  

---

  

## 第三章：静态链接 vs 动态链接

  

### 3.1 两种链接方式

  

编译程序时，运行时库可以用两种方式链接：

  

```

┌─────────────────────────────────────────────────────────────────┐

│                        静态链接 (/MT)                            │

├─────────────────────────────────────────────────────────────────┤

│                                                                 │

│   编译时：把运行时库的代码复制到你的 exe/dll 里                    │

│                                                                 │

│   ┌──────────────────────────────────────────┐                 │

│   │            你的程序.exe (10MB)            │                 │

│   │  ┌─────────────────────────────────────┐ │                 │

│   │  │ 你的代码                             │ │                 │

│   │  ├─────────────────────────────────────┤ │                 │

│   │  │ 运行时库代码（被复制进来）            │ │                 │

│   │  └─────────────────────────────────────┘ │                 │

│   └──────────────────────────────────────────┘                 │

│                                                                 │

│   优点：独立运行，不需要额外安装运行时                             │

│   缺点：体积大，无法共享，安全更新困难                             │

│                                                                 │

└─────────────────────────────────────────────────────────────────┘

  

┌─────────────────────────────────────────────────────────────────┐

│                        动态链接 (/MD)                            │

├─────────────────────────────────────────────────────────────────┤

│                                                                 │

│   编译时：只记录"我需要调用运行时库的某个函数"                      │

│   运行时：从系统目录加载 DLL                                      │

│                                                                 │

│   ┌─────────────────┐      ┌─────────────────────────┐         │

│   │ 你的程序.exe    │ ───→ │ vcruntime140.dll        │         │

│   │ (500KB)         │      │ msvcp140.dll            │         │

│   │                 │      │ (系统目录，所有程序共享)  │         │

│   │ "我需要 printf" │      │                         │         │

│   └─────────────────┘      └─────────────────────────┘         │

│                                                                 │

│   优点：体积小，多程序共享，安全更新方便                           │

│   缺点：需要目标机器安装对应版本的运行时                           │

│                                                                 │

└─────────────────────────────────────────────────────────────────┘

```

  

### 3.2 为什么大多数软件选择动态链接？

  

1. **节省磁盘和内存**：100 个程序共用一份运行时，而不是各自带一份

2. **安全更新**：微软发现漏洞后，更新一个 DLL 就能修复所有程序

3. **许可证要求**：某些库要求动态链接

  

**ONNX Runtime 使用动态链接**，所以它依赖 VC++ 运行时 DLL。

  

---

  

## 第四章：版本兼容性的秘密

  

### 4.1 为什么 2015-2022 是一个"大版本"？

  

微软从 VS2015 开始做了一个重要决定：**运行时库二进制兼容**。

  

```

┌────────────────────────────────────────────────────────────────┐

│                    运行时版本历史                               │

├────────────────────────────────────────────────────────────────┤

│                                                                │

│   VS2010 ──→ msvcr100.dll  ┐                                  │

│   VS2012 ──→ msvcr110.dll  ├── 每个版本独立，互不兼容           │

│   VS2013 ──→ msvcr120.dll  ┘                                  │

│                                                                │

│   ════════════════ 分水岭 ════════════════                     │

│                                                                │

│   VS2015 ──→ vcruntime140.dll  ┐                              │

│   VS2017 ──→ vcruntime140.dll  ├── 共享同一套运行时！           │

│   VS2019 ──→ vcruntime140.dll  │   二进制兼容                  │

│   VS2022 ──→ vcruntime140.dll  ┘                              │

│                                                                │

│   但是！VS2019/2022 可能需要 vcruntime140_1.dll（扩展）         │

│                                                                │

└────────────────────────────────────────────────────────────────┘

```

  

### 4.2 向后兼容 vs 向前兼容

  

```

                    时间轴

    ─────────────────────────────────────→

  

    2015        2017        2019        2022

      │           │           │           │

      ▼           ▼           ▼           ▼

    ┌───┐       ┌───┐       ┌───┐       ┌───┐

    │1.0│ ───→  │1.1│ ───→  │1.2│ ───→  │1.3│   运行时版本

    └───┘       └───┘       └───┘       └───┘

  
  

    向后兼容（✅ 支持）：

    ────────────────────

    用 VS2015 编译的程序 → 可以用 2022 版运行时运行

    （新运行时包含旧功能）

  
  

    向前兼容（❌ 不支持）：

    ────────────────────

    用 VS2022 编译的程序 → 不能用 2015 版运行时运行

    （旧运行时缺少新功能）

```

  

### 4.3 你的问题就出在这里！

  

```

┌─────────────────────────────────────────────────────────────┐

│                      你的情况                                │

├─────────────────────────────────────────────────────────────┤

│                                                             │

│   ONNX Runtime 1.23.2                                       │

│   └── 使用 VS2022 编译                                       │

│       └── 可能使用了 2019/2022 才有的新特性                   │

│           └── 需要 vcruntime140_1.dll 中的新函数              │

│                                                             │

│   目标电脑                                                   │

│   └── 安装了 VC++ 2015-2019                                  │

│       └── 有 vcruntime140.dll ✅                            │

│       └── vcruntime140_1.dll 版本过旧 ❌                     │

│           └── 缺少 VS2022 新增的函数                         │

│               └── DLL 初始化失败！                           │

│                                                             │

└─────────────────────────────────────────────────────────────┘

```

  

---

  

## 第五章：DLL 初始化失败的真相

  

### 5.1 DLL 加载的生命周期

  

当程序加载一个 DLL 时，会经历以下步骤：

  

```

程序启动

    │

    ▼

┌─────────────────────────────────────────────────────────┐

│ 1. 搜索 DLL 文件                                         │

│    - 程序目录 → 系统目录 → PATH 环境变量                   │

│    - 找不到？抛出 DllNotFoundException                    │

└─────────────────────────────────────────────────────────┘

    │ 找到了

    ▼

┌─────────────────────────────────────────────────────────┐

│ 2. 递归加载依赖                                          │

│    - onnxruntime.dll 依赖 vcruntime140.dll               │

│    - vcruntime140.dll 依赖 ucrtbase.dll                  │

│    - 依赖缺失？加载失败                                   │

└─────────────────────────────────────────────────────────┘

    │ 依赖都有

    ▼

┌─────────────────────────────────────────────────────────┐

│ 3. 映射到内存                                            │

│    - 把 DLL 文件内容加载到进程地址空间                     │

└─────────────────────────────────────────────────────────┘

    │

    ▼

┌─────────────────────────────────────────────────────────┐

│ 4. 解析导入表                                            │

│    - 查找 DLL 需要调用的外部函数地址                       │

│    - 函数不存在？EntryPointNotFoundException              │

└─────────────────────────────────────────────────────────┘

    │

    ▼

┌─────────────────────────────────────────────────────────────┐

│ 5. 执行 DllMain(DLL_PROCESS_ATTACH)  ← 你的错误发生在这里！ │

│                                                             │

│    DllMain 是 DLL 的"构造函数"，用于初始化：                 │

│    - 分配全局资源                                           │

│    - 初始化静态变量                                         │

│    - 检查运行环境                                           │

│                                                             │

│    如果初始化代码失败（比如调用了不存在的运行时函数）：        │

│    → "动态链接库(DLL)初始化例程失败"                         │

└─────────────────────────────────────────────────────────────┘

```

  

### 5.2 为什么 Dependencies 检测不到？

  

Dependencies 工具只能做**静态分析**：

  

```

Dependencies 能检测的：

├── DLL 文件是否存在 ✅

├── 导入表中声明的函数是否在依赖 DLL 中导出 ✅

└── PE 文件格式是否正确 ✅

  

Dependencies 不能检测的：

├── DllMain 运行时会调用什么函数 ❌

├── 运行时库版本是否足够新 ❌

├── CPU 指令集是否支持 ❌

└── 延迟加载的依赖 ❌

```

  

**你的情况**：

- 静态依赖都存在（Dependencies 说没问题）

- 但 DllMain 执行时调用了 vcruntime140_1.dll 中的新函数

- 你的旧版本运行时里没有这个函数

- → 初始化失败

  

---

  

## 第六章：解决方案

  

### 6.1 对于用户（推荐）

  

安装最新版 VC++ Redistributable：

  

```

Microsoft Visual C++ 2015-2022 Redistributable (x64)

下载地址：https://aka.ms/vs/17/release/vc_redist.x64.exe

```

  

这个安装包会：

- 安装/更新所有 vcruntime140*.dll

- 安装/更新所有 msvcp140*.dll

- 不会影响已有程序

  

### 6.2 对于开发者

  

**方案 A：随程序分发运行时安装包**

```

在安装程序中包含 vc_redist.x64.exe

或使用 Inno Setup / NSIS 自动检测并安装

```

  

**方案 B：使用静态链接编译**

```

在 Visual Studio 中：

项目属性 → C/C++ → 代码生成 → 运行库 → 多线程 (/MT)

  

缺点：无法静态链接第三方动态库（如 onnxruntime）

```

  

**方案 C：将运行时 DLL 放在程序目录**

```

把 vcruntime140.dll、msvcp140.dll 等复制到 exe 同目录

Windows 会优先加载程序目录的 DLL

  

注意：这可能违反微软的许可协议，仅限特殊场景使用

```

  

---

  

## 第七章：总结

  

### 核心知识点

  

1. **C/C++ 程序依赖运行时库**：你写的代码只是冰山一角，printf、cout、new 等基础功能都在运行时库里实现。

  

2. **动态链接是主流**：大多数程序选择动态链接运行时库，好处是体积小、可共享、易更新，代价是需要目标机器安装对应版本。

  

3. **VS2015-2022 共享运行时但有扩展**：虽然它们共用 vcruntime140.dll，但新版本会添加 vcruntime140_1.dll 等扩展，旧版本没有。

  

4. **DLL 初始化失败 ≠ DLL 缺失**：文件存在不代表能用，DllMain 执行时可能因为运行时版本不够新而失败。

  

5. **Dependencies 的局限性**：它只能做静态分析，无法检测运行时的动态行为。

  

### 一图流总结

  

```

                    程序运行依赖关系

  

    ┌─────────────────────────────────────────────┐

    │              你的程序 / DLL                  │

    │         (使用 VS2022 编译)                   │

    └──────────────────┬──────────────────────────┘

                       │ 依赖

                       ▼

    ┌─────────────────────────────────────────────┐

    │         VC++ 运行时库 (动态链接)              │

    │  vcruntime140.dll + vcruntime140_1.dll      │

    │  msvcp140.dll + msvcp140_1.dll + ...        │

    └──────────────────┬──────────────────────────┘

                       │ 依赖

                       ▼

    ┌─────────────────────────────────────────────┐

    │      通用 C 运行时 (UCRT)                    │

    │      ucrtbase.dll (Windows 10+ 自带)         │

    └──────────────────┬──────────────────────────┘

                       │ 依赖

                       ▼

    ┌─────────────────────────────────────────────┐

    │           Windows 操作系统                   │

    │     kernel32.dll, ntdll.dll, ...            │

    └─────────────────────────────────────────────┘

  
  

    任何一层缺失或版本不对 → 程序无法运行

```

  

---

  

## 附录：常见错误对照表

  

| 错误信息 | 含义 | 解决方案 |

|---------|------|---------|

| 找不到 vcruntime140.dll | 运行时完全未安装 | 安装 VC++ Redistributable |

| 找不到 msvcp140.dll | C++ 标准库未安装 | 安装 VC++ Redistributable |

| DLL 初始化例程失败 | 运行时版本过旧 | 更新到最新版 Redistributable |

| EntryPointNotFoundException | 函数不存在 | 检查 DLL 版本匹配 |

| BadImageFormatException | 32/64位不匹配 | 使用正确架构的 DLL |

  

---

  

*本文档旨在帮助开发者理解 VC++ 运行时的工作原理，解决常见的 DLL 依赖问题。*